use crate::{
    database::DB_POOL,
    formatting::timestamp_to_string,
    load_config::{read_config, Config},
};
use binance_spot_connector_rust::{
    http::Credentials,
    hyper::BinanceHttpClient,
    market::{self, klines::KlineInterval},
    market_stream::kline::KlineStream,
    tungstenite::BinanceWebSocketClient,
};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tokio::time::sleep;

#[derive(Debug, Deserialize)]
struct Kline {
    open_time: u64,
    open: String,
    high: String,
    low: String,
    close: String,
    volume: String,
    close_time: u64,
    quote_asset_volume: String,
    trades: u64,
    taker_buy_base_asset_volume: String,
    taker_buy_quote_asset_volume: String,
    ignore: String,
}

#[derive(Debug, Deserialize)]
struct KlinesResponse {
    klines: Vec<Kline>,
}

const BINANCE_WSS_BASE_URL: &str = "wss://stream.binance.com:9443/ws";

async fn subscribe_to_price_updates() {
    // Establish connection
    let mut conn =
        BinanceWebSocketClient::connect_with_url(BINANCE_WSS_BASE_URL).expect("Failed to connect");
    // Subscribe to streams
    conn.subscribe(vec![
        &KlineStream::new("BTCUSDT", KlineInterval::Minutes1).into(),
        &KlineStream::new("BNBBUSD", KlineInterval::Minutes3).into(),
    ]);
    // Read messages
    while let Ok(message) = conn.as_mut().read_message() {
        let data = message.into_data();
        let string_data = String::from_utf8(data).expect("Found invalid UTF-8 chars");
        println!("Socket tick.");
    }
    // Disconnect
    conn.close().expect("Failed to disconnect");

    // TODO: Update to database
}

async fn update() {
    loop {
        sleep(Duration::from_secs(10)).await;
    }
}

async fn fetch_history(symbol: &str) -> Result<(), String> {
    let mut start_time = 0;
    let config: Config = read_config();
    let credentials = Credentials::from_hmac(
        config.binance_api_key.to_owned(),
        config.binance_api_secret.to_owned(),
    );
    let mut klines: Vec<Kline> = Vec::new();
    let client = BinanceHttpClient::default().credentials(credentials);
    loop {
        println!(
            "Loading candles from: {:?}",
            timestamp_to_string(start_time)
        );
        let request = market::klines("BTCUSDT", KlineInterval::Minutes1)
            .start_time(0)
            .limit(1000);
        let data = client.send(request).await?.into_body_str().await?;
        let data: KlinesResponse = serde_json::from_str(data).unwrap();
        if data.klines.is_empty() {
            break;
        } else {
            klines.extend(data.klines);
            sleep(Duration::from_secs(1)).await;
        }
    }
    if klines.is_empty() {
        Err(String::from("No history klines inserted."))
    } else {
        let connection = &DB_POOL.get();
        for kline in klines {
            sqlx::query(
            "INSERT INTO klines (symbol, open_time, open, high, low, close, volume, close_time, quote_asset_volume, number_of_trades, taker_buy_base_asset_volume, taker_buy_quote_asset_volume)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)",
            symbol,
            kline.open_time,
            kline.open,
            kline.high,
            kline.low,
            kline.close,
            kline.volume,
            kline.close_time,
            kline.quote_asset_volume,
            kline.trades,
            kline.taker_buy_base_asset_volume,
            kline.taker_buy_quote_asset_volume,
        )
        .execute(connection)
        .await?;
        }
    }
}

pub async fn main() {
    // start updating book records
    tokio::spawn(update());
    tokio::spawn(subscribe_to_price_updates());
}
